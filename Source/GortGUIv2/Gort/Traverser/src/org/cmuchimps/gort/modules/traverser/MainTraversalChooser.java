/*
   Copyright 2014 Shahriyar Amini

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
package org.cmuchimps.gort.modules.traverser;

import java.awt.BorderLayout;
import org.cmuchimps.gort.api.gort.ProjectDirectoryService;
import org.netbeans.api.project.Project;
import org.netbeans.spi.project.ui.LogicalViewProvider;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.view.BeanTreeView;
import org.openide.filesystems.FileObject;
import org.openide.loaders.DataFolder;
import org.openide.loaders.DataObject;
import org.openide.nodes.Children;
import org.openide.nodes.FilterNode;
import org.openide.nodes.Node;
import org.openide.util.NbBundle;

/**
 *
 * @author shahriyar
 */
@NbBundle.Messages("LBL_ChooseMainTraversal=Select Main Traversal")
public class MainTraversalChooser extends javax.swing.JPanel implements
        ExplorerManager.Provider {
    
    private final ExplorerManager mgr = new ExplorerManager();
    private final Project project;
    private final FileObject apk;
    private final String apkFilename;

    /**
     * Creates new form MainTraversalChooser
     */
    public MainTraversalChooser(Project project, FileObject apk) {
        this.project = project;
        this.apk = apk;
        this.apkFilename = apk.getNameExt();
        
        initComponents();
        
        //instructionJLabel.setText("Select Main Traversal");
        
        setLayout(new BorderLayout());
        
        LogicalViewProvider logicalView = (LogicalViewProvider) project.getLookup().lookup(LogicalViewProvider.class);
        
        Node projectNode = logicalView.createLogicalView();
        
        mgr.setRootContext(new FilterNode(projectNode, new ProjectFilterChildren(projectNode)));
        
        BeanTreeView btv = new BeanTreeView();
        
        traversalNodeJScrollPane.setViewportView(btv);
        
        btv.setPopupAllowed(false);
        
        //btv.setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        
        add(btv, BorderLayout.CENTER);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        instructionJLabel = new javax.swing.JLabel();
        traversalNodeJScrollPane = new javax.swing.JScrollPane();

        instructionJLabel.setText(org.openide.util.NbBundle.getMessage(MainTraversalChooser.class, "MainTraversalChooser.instructionJLabel.text")); // NOI18N

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(traversalNodeJScrollPane)
                    .add(instructionJLabel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 388, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(instructionJLabel)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(traversalNodeJScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 266, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel instructionJLabel;
    private javax.swing.JScrollPane traversalNodeJScrollPane;
    // End of variables declaration//GEN-END:variables

    @Override
    public ExplorerManager getExplorerManager() {
        return mgr;
    }
    
    private FileObject getAppsDir() {
        if (project == null) {
            return null;
        }
        
        ProjectDirectoryService pds = project.getLookup().lookup(ProjectDirectoryService.class);
            
        if (pds == null) {
            return null;
        }
        
        return pds.getAppsDir();
    }
    
    private final class ProjectFilterChildren extends FilterNode.Children {

        public ProjectFilterChildren(Node projectNode) {
            super(projectNode);
        }

        @Override
        protected Node[] createNodes(Node object) {
            Node origChild = (Node) object;
            //System.out.println("\nNode name: " + origChild.getName());
            // find the associated dataobject to the child node
            DataObject dob = (DataObject) origChild.getLookup().lookup(DataObject.class);
            
            if (dob != null) {
                if (dob instanceof DataFolder) {
                    DataFolder df = (DataFolder) dob;
                    
                    //System.out.println("DataFolder name:" + df.getName());
                    
                    // if the node is the apps directory allow it
                    if (dob.getPrimaryFile().equals(getAppsDir())) {
                        return new Node[] {
                            new FilterNode(origChild, new ProjectFilterChildren(origChild))
                        };
                    } else {
                        if (df.getName().startsWith(apkFilename)) {
                            return new Node[] {
                                new FilterNode(origChild, Children.LEAF)
                            };
                        }
                    }
                    
                } else {
                    // out of file objects only the associated APK is returned
                    if (dob.getPrimaryFile().equals(apk)) {
                        return new Node[] {
                            new FilterNode(origChild, new ProjectFilterChildren(origChild))
                        };
                    }
                }
            } else {
                System.out.println("No associated data object");
            }
        
            return new Node[0];
        }
    }
}
